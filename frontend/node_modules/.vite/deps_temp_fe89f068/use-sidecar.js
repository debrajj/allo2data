import {
  require_react
} from "./chunk-3TFVT2CW.js";
import {
  __toESM
} from "./chunk-4MBMRILA.js";

// ../node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// ../node_modules/use-sidecar/dist/es2015/hoc.js
var React = __toESM(require_react());

// ../node_modules/use-sidecar/dist/es2015/hook.js
var import_react = __toESM(require_react());

// ../node_modules/detect-node-es/esm/browser.js
var isNode = false;

// ../node_modules/use-sidecar/dist/es2015/env.js
var env = {
  isNode,
  forceCache: false
};

// ../node_modules/use-sidecar/dist/es2015/hook.js
var cache = /* @__PURE__ */ new WeakMap();
var NO_OPTIONS = {};
function useSidecar(importer, effect) {
  var options = effect && effect.options || NO_OPTIONS;
  if (env.isNode && !options.ssr) {
    return [null, null];
  }
  return useRealSidecar(importer, effect);
}
function useRealSidecar(importer, effect) {
  var options = effect && effect.options || NO_OPTIONS;
  var couldUseCache = env.forceCache || env.isNode && !!options.ssr || !options.async;
  var _a = (0, import_react.useState)(couldUseCache ? function() {
    return cache.get(importer);
  } : void 0), Car = _a[0], setCar = _a[1];
  var _b = (0, import_react.useState)(null), error = _b[0], setError = _b[1];
  (0, import_react.useEffect)(function() {
    if (!Car) {
      importer().then(function(car) {
        var resolved = effect ? effect.read() : car.default || car;
        if (!resolved) {
          console.error("Sidecar error: with importer", importer);
          var error_1;
          if (effect) {
            console.error("Sidecar error: with medium", effect);
            error_1 = new Error("Sidecar medium was not found");
          } else {
            error_1 = new Error("Sidecar was not found in exports");
          }
          setError(function() {
            return error_1;
          });
          throw error_1;
        }
        cache.set(importer, resolved);
        setCar(function() {
          return resolved;
        });
      }, function(e) {
        return setError(function() {
          return e;
        });
      });
    }
  }, []);
  return [Car, error];
}

// ../node_modules/use-sidecar/dist/es2015/hoc.js
function sidecar(importer, errorComponent) {
  var ErrorCase = function() {
    return errorComponent;
  };
  return function Sidecar(props) {
    var _a = useSidecar(importer, props.sideCar), Car = _a[0], error = _a[1];
    if (error && errorComponent) {
      return ErrorCase;
    }
    return Car ? React.createElement(Car, __assign({}, props)) : null;
  };
}

// ../node_modules/use-sidecar/dist/es2015/config.js
var config = {
  onError: function(e) {
    return console.error(e);
  }
};
var setConfig = function(conf) {
  Object.assign(config, conf);
};

// ../node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  return innerCreateMedium(defaults, middleware);
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../node_modules/use-sidecar/dist/es2015/renderProp.js
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());
function renderCar(WrappedComponent, defaults) {
  function State(_a) {
    var stateRef = _a.stateRef, props = _a.props;
    var renderTarget = (0, import_react2.useCallback)(function SideTarget() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      (0, import_react2.useLayoutEffect)(function() {
        stateRef.current(args);
      });
      return null;
    }, []);
    return React2.createElement(WrappedComponent, __assign({}, props, { children: renderTarget }));
  }
  var Children = React2.memo(function(_a) {
    var stateRef = _a.stateRef, defaultState = _a.defaultState, children = _a.children;
    var _b = (0, import_react2.useState)(defaultState.current), state = _b[0], setState = _b[1];
    (0, import_react2.useEffect)(function() {
      stateRef.current = setState;
    }, []);
    return children.apply(void 0, state);
  }, function() {
    return true;
  });
  return function Combiner(props) {
    var defaultState = React2.useRef(defaults(props));
    var ref = React2.useRef(function(state) {
      return defaultState.current = state;
    });
    return React2.createElement(
      React2.Fragment,
      null,
      React2.createElement(State, { stateRef: ref, props }),
      React2.createElement(Children, { stateRef: ref, defaultState, children: props.children })
    );
  };
}

// ../node_modules/use-sidecar/dist/es2015/exports.js
var React3 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React3.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}
export {
  createMedium,
  createSidecarMedium,
  exportSidecar,
  renderCar,
  setConfig,
  sidecar,
  useSidecar
};
//# sourceMappingURL=use-sidecar.js.map
